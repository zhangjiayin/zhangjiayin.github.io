---
layout: post
title: Linux的Shell编程之Shell程序设计的流程控制[转]
date: 2007-07-27 11:33:00.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  dsq_thread_id: '4543640962'
author: 
permalink: "/2007/07/linux%e7%9a%84shell%e7%bc%96%e7%a8%8b%e4%b9%8bshell%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%9a%84%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6%e8%bd%ac.html"
---
  
<font size="2">和其他高级程序设计语言一样，Shell提供了用来控制程序执行流程的命令，包括条件分支和循环结构，用户可以用这些命令创建非常复杂的程序。
<p>　　与传统语言不同的是，Shell用于指定条件值的不是布尔运算式，而是命令和字串。</p>
<p>　　1．测试命令</p>
<p>　　test命令用于检查某个条件是否成立，它可以进行数值、字符和文件3个方面的测试，其测试符和相应的功能分别如下。</p>
<p>　　（1）数值测试：</p>
<p>　　-eq 等于则为真。</p>
<p>　　-ne 不等于则为真。</p>
<p>　　-gt 大于则为真。</p>
<p>　　-ge 大于等于则为真。</p>
<p>　　-lt 小于则为真。</p>
<p>　　-le 小于等于则为真。</p>
<p>　　（2）字串测试：</p>
<p>　　= 等于则为真。</p>
<p>　　!= 不相等则为真。</p>
<p>　　-z字串 字串长度伪则为真。</p>
<p>　　-n字串 字串长度不伪则为真。</p>
<p>　　（3）文件测试：</p>
<p>　　-e文件名 如果文件存在则为真。</p>
<p>　　-r文件名 如果文件存在且可读则为真。</p>
<p>　　-w文件名 如果文件存在且可写则为真。</p>
<p>　　-x文件名 如果文件存在且可执行则为真。</p>
<p>　　-s文件名 如果文件存在且至少有一个字符则为真。</p>
<p>　　-d文件名 如果文件存在且为目录则为真。</p>
<p>　　-f文件名 如果文件存在且为普通文件则为真。</p>
<p>　　-c文件名 如果文件存在且为字符型特殊文件则为真。</p>
<p>　　-b文件名 如果文件存在且为块特殊文件则为真。</p>
<p>　　另外，Linux还提供了与（！）、或（-o）、非（-a）三个逻辑操作符，用于将测试条件连接起来，其优先顺序为：！最高，-a次之，-o最低。</p>
<p>　　同时，bash也能完成简单的算术运算，格式如下：</p>
<p>　　$[expression]</p>
<p>　　例如：</p>
<p>　　var1=2</p>
<p>　　var2=$[var1*10+1]</p>
<p>　　则var2的值为21。</p>
<p>　　2．if条件语句</p>
<p>　　Shell程序中的条件分支是通过if条件语句来实现的，其一般格式为：</p>
<p>　　if 条件命令串</p>
<p>　　then</p>
<p>　　条件为真时的命令串</p>
<p>　　else</p>
<p>　　条件为假时的命令串</p>
<p>　　fi</p>
<p>　　3．for循环</p>
<p>　　for循环对一个变量的可能的值都执行一个命令序列。赋给变量的几个数值既可以在程序内以数值列表的形式提供，也可以在程序以外以位置参数的形式提供。for循环的一般格式为：</p>
<p>　　for变量名 　 　[in数值列表]</p>
<p>　　do</p>
<p>　　若干个命令行</p>
<p>　　done</p>
<p>　　变量名可以是用户选择的任何字串，如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的$var。如果省略了in，则变量var的取值将是位置参数。对变量的每一个可能的赋值都将执行do和done之间的命令列表。</p>
<p>　　4．while和until循环</p>
<p>　　while和until命令都是用命令的返回状态值来控制循环的。While循环的一般格式为：</p>
<p>　　while</p>
<p>　　若干个命令行1</p>
<p>　　do</p>
<p>　　若干个命令行2</p>
<p>　　done</p>
<p>　　只要while的“若干个命令行1”中最后一个命令的返回状态为真，while循环就继续执行do...done之间的“若干个命令行2”。</p>
<p>　　until命令是另一种循环结构，它和while命令相似，其格式如下：</p>
<p>　　until</p>
<p>　　 若干个命令行1</p>
<p>　　do</p>
<p>　　 若干个命令行2</p>
<p>　　done</p>
<p>　　until循环和while循环的区别在于：while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环。</p>
<p>　　Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0。</p>
<p>　　5．case条件选择</p>
<p>　　if条件语句用于在两个选项中选定一项，而case条件选择为用户提供了根据字串或变量的值从多个选项中选择一项的方法，其格式如下：</p>
<p>　　case string in</p>
<p>　　exp-1)</p>
<p>　　若干个命令行1</p>
<p>　　；；</p>
<p>　　exp-2)</p>
<p>　　 若干个命令行2</p>
<p>　　；；</p>
<p>　　……</p>
<p>　　*)</p>
<p>　　其他命令行</p>
<p>　　esac</p>
<p>　　Shell通过计算字串string的值，将其结果依次和运算式exp-1, exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号(；；)为止。</p>
<p>　　在case运算式中也可以使用Shell的通配符（“*”、“？”、“[]”）。通常用 * 作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行”的命令。</p>
<p>　　6．无条件控制语句break和continue</p>
<p>　　break用于立即终止当前循环的执行，而contiune用于不执行循环中后面的语句而立即开始下一个循环的执行。这两个语句只有放在do和done之间才有效。</p>
<p>　　7．函数定义</p>
<p>　　在Shell中还可以定义函数。函数实际上也是由若干条Shell命令组成的，因此它与Shell程序形式上是相似的，不同的是它不是一个单独的进程，而是Shell程序的一部分。函数定义的基本格式为：</p>
<p>　　functionname</p>
<p>　　{</p>
<p>　　 若干命令行</p>
<p>　　}</p>
<p>　　调用函数的格式为：</p>
<p>　　functionname param1 param2…</p>
<p>　　Shell函数可以完成某些例行的工作，而且还可以有自己的退出状态，因此函数也可以作为if, while等控制结构的条件。</p>
<p>　　在函数定义时不用带参数说明，但在调用函数时可以带有参数，此时Shell将把这些参数分别赋予相应的位置参数$1, $2, ...及$*。</p>
<p>　　8．命令分组</p>
<p>　　在Shell中有两种命令分组的方法：()和{}。前者当Shell执行()中的命令时将再创建一个新的子进程，然后这个子进程去执行圆括弧中的命令。当用户在执行某个命令时不想让命令运行时对状态集合（如位置参数、环境变量、当前工作目录等）的改变影响到下面语句的执行时，就应该把这些命令放在圆括弧中，这样就能保证所有的改变只对子进程产生影响，而父进程不受任何干扰。{}用于将顺序执行的命令的输出结果用于另一个命令的输入（管道方式）。当我们要真正使用圆括弧和花括弧时（如计算运算式的优先顺序），则需要在其前面加上转义符（\）以便让Shell知道它们不是用于命令执行的控制所用。</p>
<p>　　9．信号</p>
<p>　　trap命令用于在Shell程序中捕捉信号，之后可以有3种反应方式：</p>
<p>　　（1）执行一段程序来处理这一信号。</p>
<p>　　（2）接受信号的默认操作。</p>
<p>　　（3）忽视这一信号。</p>
<p>　　trap对上面3种方式提供了3种基本形式：</p>
<p>　　第一种形式的trap命令在Shell接收到与signal list清单中数值相同的信号时，将执行双引号中的命令串。</p>
<p>　　trap 'commands' signal-list</p>
<p>　　trap "commands" signal-list</p>
<p>　　为了恢复信号的默认操作，使用第二种形式的trap命令：</p>
<p>　　trap signal-list</p>
<p>　　第三种形式的trap命令允许忽略信号：</p>
<p>　　trap " " signal-list</p>
<p>　　注意：</p>
<p>　　（1）对信号11（段违例）不能捕捉，因为Shell本身需要捕捉该信号去进行内存的转储。</p>
<p>　　（2）在trap中可以定义对信号0的处理（实际上没有这个信号），Shell程序在其终止（如执行exit语句）时发出该信号。</p>
<p>　　（3）在捕捉到signal-list中指定的信号并执行完相应的命令之后，如果这些命令没有将Shell程序终止的话，Shell程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致Shell程序无法终止。</p>
<p>　　另外，在trap语句中，单引号和双引号是不同的。当Shell程序第一次碰到trap语句时，将把commands中的命令扫描一遍。此时若commands是用单引号括起来的话，那么Shell不会对commands中的变量和命令进行替换，否则commands中的变量和命令将用当时具体的值来替换。</p></font>  

]]\>

